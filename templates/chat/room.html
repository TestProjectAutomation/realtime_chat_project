<!-- room.html - ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© -->

<!-- Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… ÙÙŠ room.html -->

<!-- Pinned Messages Sidebar -->
<div id="pinned-sidebar" class="hidden lg:block w-64 border-l border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 overflow-y-auto">
    <div class="p-4">
        <div class="flex items-center justify-between mb-4">
            <h4 class="font-semibold text-gray-900 dark:text-white">
                <i class="fas fa-thumbtack text-yellow-500 mr-2"></i>
                {% trans "Pinned Messages" %}
            </h4>
            <span class="text-xs text-gray-500">({{ pinned_messages|length }})</span>
        </div>
        
        <div class="space-y-3">
            {% for message in pinned_messages %}
                <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg border border-yellow-200 dark:border-yellow-800">
                    <div class="flex items-center space-x-2 mb-2">
                        {% if message.sender.profile.profile_picture %}
                            <img src="{{ message.sender.profile.profile_picture.url }}" 
                                 alt="{{ message.sender.username }}"
                                 class="w-6 h-6 rounded-full">
                        {% else %}
                            <div class="w-6 h-6 rounded-full bg-gradient-to-r from-blue-400 to-purple-500 flex items-center justify-center">
                                <span class="text-white text-xs font-bold">
                                    {{ message.sender.username|first|upper }}
                                </span>
                            </div>
                        {% endif %}
                        <span class="text-xs font-medium text-gray-700 dark:text-gray-300">
                            {{ message.sender.username }}
                        </span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">{{ message.content|truncatechars:80 }}</p>
                    <div class="flex items-center justify-between">
                        <span class="text-xs text-gray-500">{{ message.created|date:"M d, H:i" }}</span>
                        <button onclick="unpinMessage('{{ message.id }}')" 
                                class="text-xs text-gray-500 hover:text-red-500">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            {% empty %}
                <p class="text-sm text-gray-500 dark:text-gray-400 text-center py-4">
                    {% trans "No pinned messages" %}
                </p>
            {% endfor %}
        </div>
    </div>
</div>

<!-- Ø¥Ø¶Ø§ÙØ© ÙÙŠ Ù‚Ø³Ù… JavaScript -->
<script>
    // Enhanced chat functionality
    
    class EnhancedChat {
        constructor(config) {
            this.config = config;
            this.socket = null;
            this.typingTimeout = null;
            this.lastTypingTime = 0;
            this.isTyping = false;
            this.initialize();
        }
        
        initialize() {
            this.connectWebSocket();
            this.setupEventListeners();
            this.loadMoreMessages();
            this.setupInfiniteScroll();
        }
        
        connectWebSocket() {
            const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
            const wsUrl = `${wsScheme}://${window.location.host}/ws/chat/${this.config.roomId}/`;
            
            this.socket = new WebSocket(wsUrl);
            
            this.socket.onmessage = (e) => {
                const data = JSON.parse(e.data);
                this.handleWebSocketMessage(data);
            };
            
            this.socket.onopen = () => {
                console.log('WebSocket connected');
                this.sendUserStatus(true);
            };
            
            this.socket.onclose = () => {
                console.log('WebSocket disconnected. Reconnecting...');
                setTimeout(() => this.connectWebSocket(), 3000);
            };
        }
        
        handleWebSocketMessage(data) {
            switch(data.type) {
                case 'chat_message':
                    this.appendMessage(data);
                    break;
                case 'typing_indicator':
                    this.showTypingIndicator(data);
                    break;
                case 'user_status':
                    this.updateUserStatus(data);
                    break;
                case 'read_receipt':
                    this.updateReadReceipt(data);
                    break;
                case 'message_reaction':
                    this.updateMessageReaction(data);
                    break;
                case 'message_deleted':
                    this.deleteMessage(data.message_id);
                    break;
                case 'message_pinned':
                    this.pinMessage(data);
                    break;
            }
        }
        
        appendMessage(data) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageHTML = this.createMessageHTML(data);
            
            // Check if message already exists
            const existingMessage = document.querySelector(`[data-message-id="${data.message_id}"]`);
            if (existingMessage) {
                existingMessage.replaceWith(messageHTML);
            } else {
                messagesContainer.insertAdjacentHTML('beforeend', messageHTML);
            }
            
            // Scroll to bottom
            this.scrollToBottom();
            
            // Play notification sound if not sender
            if (parseInt(data.sender_id) !== this.config.currentUserId) {
                this.playNotificationSound();
                this.showDesktopNotification(data);
            }
        }
        
        createMessageHTML(data) {
            const isSender = parseInt(data.sender_id) === this.config.currentUserId;
            const isGroup = this.config.isGroupChat;
            const timestamp = new Date(data.timestamp).toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            return `
                <div class="message-item ${isSender ? 'message-sent-item' : 'message-received-item'}"
                     data-message-id="${data.message_id}">
                    <div class="flex ${isSender ? 'justify-end' : 'justify-start'}">
                        <div class="max-w-[70%] md:max-w-[60%]">
                            ${!isSender && isGroup ? `
                                <div class="flex items-center space-x-2 mb-1">
                                    <div class="w-6 h-6 rounded-full bg-gradient-to-r from-blue-400 to-purple-500 flex items-center justify-center">
                                        <span class="text-white text-xs font-bold">${data.sender[0].toUpperCase()}</span>
                                    </div>
                                    <span class="font-semibold text-xs text-gray-700 dark:text-gray-300">
                                        ${data.sender}
                                    </span>
                                </div>
                            ` : ''}
                            
                            <div class="message-bubble px-4 py-3 ${isSender ? 'message-sent' : 'message-received'} 
                                 hover:bg-opacity-90 cursor-pointer"
                                 onclick="showMessageOptions('${data.message_id}')">
                                ${data.message_type === 'image' ? `
                                    <div class="mb-2">
                                        <img src="${data.file_url}" 
                                             alt="Image" 
                                             class="max-w-full rounded-lg cursor-pointer"
                                             onclick="openImageViewer('${data.file_url}')">
                                    </div>
                                ` : data.message_type === 'file' ? `
                                    <div class="flex items-center space-x-3 p-3 bg-black/10 dark:bg-white/10 rounded-lg">
                                        <i class="fas fa-file text-2xl text-blue-500"></i>
                                        <div class="flex-1">
                                            <p class="font-medium truncate">${data.file_name}</p>
                                            <p class="text-xs text-gray-500">${this.formatFileSize(data.file_size)}</p>
                                        </div>
                                        <a href="${data.file_url}" 
                                           download="${data.file_name}"
                                           class="p-2 hover:bg-black/20 dark:hover:bg-white/20 rounded-lg">
                                            <i class="fas fa-download"></i>
                                        </a>
                                    </div>
                                ` : `
                                    <div class="mb-1 whitespace-pre-wrap">${this.escapeHtml(data.content)}</div>
                                `}
                                
                                <div class="flex items-center justify-between mt-2">
                                    <span class="text-xs opacity-75">${timestamp}</span>
                                    ${isSender ? `
                                        <div class="flex items-center space-x-1 ml-2">
                                            <i class="fas fa-check${data.is_read ? '-double text-blue-400' : ' text-gray-400'}"></i>
                                        </div>
                                    ` : ''}
                                </div>
                                
                                <!-- Reactions -->
                                <div class="message-reactions mt-2 flex flex-wrap gap-1">
                                    ${data.reactions ? this.renderReactions(data.reactions) : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        renderReactions(reactions) {
            const reactionMap = {
                'like': 'ðŸ‘',
                'love': 'â¤ï¸',
                'haha': 'ðŸ˜‚',
                'wow': 'ðŸ˜®',
                'sad': 'ðŸ˜¢',
                'angry': 'ðŸ˜ '
            };
            
            // Group reactions by type
            const grouped = {};
            reactions.forEach(r => {
                if (!grouped[r.reaction]) grouped[r.reaction] = [];
                grouped[r.reaction].push(r.user_id);
            });
            
            let html = '';
            for (const [reactionType, userIds] of Object.entries(grouped)) {
                const isReacted = userIds.includes(this.config.currentUserId);
                html += `
                    <button onclick="toggleReaction('${reactionType}')"
                            class="px-2 py-1 text-xs rounded-full ${isReacted ? 
                                'bg-primary-500 text-white' : 
                                'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300'}">
                        ${reactionMap[reactionType]} ${userIds.length}
                    </button>
                `;
            }
            return html;
        }
        
        showTypingIndicator(data) {
            const indicator = document.getElementById('typing-indicator');
            if (!data.is_typing) {
                indicator.classList.add('hidden');
                return;
            }
            
            indicator.classList.remove('hidden');
            
            // Update typing user display
            const typingUser = document.querySelector('.typing-user');
            if (typingUser) {
                typingUser.textContent = data.username;
            }
            
            // Hide after 3 seconds
            clearTimeout(this.typingTimeout);
            this.typingTimeout = setTimeout(() => {
                indicator.classList.add('hidden');
            }, 3000);
        }
        
        sendTypingStatus(isTyping) {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                const now = Date.now();
                // Throttle typing events
                if (isTyping && (now - this.lastTypingTime > 1000)) {
                    this.socket.send(JSON.stringify({
                        type: 'typing',
                        is_typing: true
                    }));
                    this.lastTypingTime = now;
                } else if (!isTyping && this.isTyping) {
                    this.socket.send(JSON.stringify({
                        type: 'typing',
                        is_typing: false
                    }));
                }
                this.isTyping = isTyping;
            }
        }
        
        sendUserStatus(online) {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify({
                    type: 'user_status',
                    online: online
                }));
            }
        }
        
        sendMessage(content, messageType = 'text', file = null) {
            if (!content.trim() && !file) return;
            
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                const messageData = {
                    type: 'chat_message',
                    message: content,
                    message_type: messageType,
                    file_url: file ? URL.createObjectURL(file) : null
                };
                
                this.socket.send(JSON.stringify(messageData));
                
                // Clear input
                const input = document.getElementById('message-input');
                if (input) {
                    input.value = '';
                    input.style.height = 'auto';
                }
                
                // Send typing stopped
                this.sendTypingStatus(false);
            }
        }
        
        scrollToBottom() {
            const container = document.getElementById('chat-messages');
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        }
        
        playNotificationSound() {
            const audio = new Audio('/static/sounds/notification.mp3');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }
        
        showDesktopNotification(data) {
            if (!("Notification" in window)) return;
            
            if (Notification.permission === "granted") {
                new Notification(`${data.sender}`, {
                    body: data.content,
                    icon: '/static/images/notification-icon.png'
                });
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        this.showDesktopNotification(data);
                    }
                });
            }
        }
        
        loadMoreMessages() {
            const container = document.getElementById('chat-messages');
            if (!container) return;
            
            container.addEventListener('scroll', () => {
                if (container.scrollTop === 0) {
                    this.fetchMoreMessages();
                }
            });
        }
        
        async fetchMoreMessages() {
            const currentMessages = document.querySelectorAll('.message-item');
            const oldestMessageId = currentMessages[0]?.dataset.messageId;
            
            try {
                const response = await fetch(`/chat/room/${this.config.roomId}/messages/?before=${oldestMessageId}`);
                const messages = await response.json();
                
                if (messages.length > 0) {
                    const fragment = document.createDocumentFragment();
                    messages.reverse().forEach(msg => {
                        const messageHTML = this.createMessageHTML(msg);
                        fragment.insertAdjacentHTML('afterbegin', messageHTML);
                    });
                    
                    const container = document.getElementById('chat-messages');
                    container.insertBefore(fragment, container.firstChild);
                    
                    // Maintain scroll position
                    const newFirstMessage = document.querySelector('.message-item');
                    if (newFirstMessage) {
                        container.scrollTop = newFirstMessage.offsetHeight * messages.length;
                    }
                }
            } catch (error) {
                console.error('Failed to load more messages:', error);
            }
        }
        
        setupInfiniteScroll() {
            let isLoading = false;
            
            window.addEventListener('scroll', () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading) {
                    isLoading = true;
                    this.fetchMoreMessages().finally(() => {
                        isLoading = false;
                    });
                }
            });
        }
        
        setupEventListeners() {
            const messageInput = document.getElementById('message-input');
            const messageForm = document.getElementById('message-form');
            
            if (messageInput) {
                // Typing detection
                messageInput.addEventListener('input', () => {
                    this.sendTypingStatus(messageInput.value.length > 0);
                });
                
                // Send message on Ctrl+Enter
                messageInput.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'Enter') {
                        e.preventDefault();
                        this.sendMessage(messageInput.value);
                    }
                });
            }
            
            if (messageForm) {
                messageForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.sendMessage(messageInput.value);
                });
            }
            
            // File upload
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.sendMessage('', 'file', file);
                    }
                });
            }
            
            // Image paste
            document.addEventListener('paste', (e) => {
                const items = e.clipboardData.items;
                for (const item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        const file = item.getAsFile();
                        this.sendMessage('', 'image', file);
                        break;
                    }
                }
            });
        }
    }
    
    // Initialize enhanced chat
    document.addEventListener('DOMContentLoaded', () => {
        const roomData = document.getElementById('room-data');
        if (roomData) {
            const config = {
                roomId: parseInt(roomData.dataset.roomId),
                roomType: roomData.dataset.roomType,
                currentUserId: parseInt(roomData.dataset.currentUserId),
                isGroupChat: roomData.dataset.isGroup === 'true'
            };
            
            window.chat = new EnhancedChat(config);
        }
        
        // Initialize message context menu
        initMessageContextMenu();
        
        // Initialize emoji picker
        initEmojiPicker();
        
        // Initialize voice recording
        initVoiceRecording();
    });
    
    // Message context menu
    function initMessageContextMenu() {
        document.addEventListener('contextmenu', (e) => {
            const messageBubble = e.target.closest('.message-bubble');
            if (messageBubble) {
                e.preventDefault();
                showMessageContextMenu(e, messageBubble);
            }
        });
    }
    
    function showMessageContextMenu(event, messageElement) {
        const menu = document.createElement('div');
        menu.className = 'fixed bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 z-50 py-1';
        menu.style.top = `${event.clientY}px`;
        menu.style.left = `${event.clientX}px`;
        
        const messageId = messageElement.closest('.message-item').dataset.messageId;
        const isSender = messageElement.classList.contains('message-sent');
        
        const menuItems = [
            { 
                icon: 'fas fa-reply', 
                text: 'Reply', 
                action: () => replyToMessage(messageId) 
            },
            { 
                icon: 'fas fa-share', 
                text: 'Forward', 
                action: () => forwardMessage(messageId) 
            },
            { 
                icon: 'fas fa-copy', 
                text: 'Copy', 
                action: () => copyMessage(messageId) 
            },
            { 
                icon: 'fas fa-thumbtack', 
                text: 'Pin', 
                action: () => pinMessage(messageId) 
            },
            { 
                icon: 'fas fa-star', 
                text: 'Save', 
                action: () => saveMessage(messageId) 
            },
            { separator: true },
            { 
                icon: 'fas fa-trash', 
                text: 'Delete', 
                action: () => deleteMessage(messageId),
                className: 'text-red-600'
            }
        ];
        
        menuItems.forEach(item => {
            if (item.separator) {
                menu.innerHTML += '<hr class="my-1 border-gray-200 dark:border-gray-700">';
            } else {
                menu.innerHTML += `
                    <button onclick="this.parentElement.remove(); ${item.action.toString().replace('()', '')}"
                            class="w-full text-left px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center ${item.className || ''}">
                        <i class="${item.icon} mr-3"></i>
                        ${item.text}
                    </button>
                `;
            }
        });
        
        document.body.appendChild(menu);
        
        // Close menu when clicking outside
        setTimeout(() => {
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            document.addEventListener('click', closeMenu);
        });
    }
    
    // Emoji picker
    function initEmojiPicker() {
        const emojiButton = document.querySelector('[onclick="toggleEmojiPicker()"]');
        if (emojiButton) {
            emojiButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const picker = document.getElementById('emoji-picker') || createEmojiPicker();
                picker.classList.toggle('hidden');
            });
        }
    }
    
    function createEmojiPicker() {
        const emojis = ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ¥°', 'ðŸ˜Ž', 'ðŸ˜œ', 'ðŸ¤”', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ˜¡', 'ðŸ‘', 'â¤ï¸', 'ðŸ”¥', 'ðŸŽ‰', 'ðŸ’¯'];
        
        const picker = document.createElement('div');
        picker.id = 'emoji-picker';
        picker.className = 'fixed bottom-20 right-4 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 p-2 grid grid-cols-6 gap-2 z-50';
        
        emojis.forEach(emoji => {
            const button = document.createElement('button');
            button.className = 'w-8 h-8 flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 rounded';
            button.textContent = emoji;
            button.onclick = () => {
                const input = document.getElementById('message-input');
                if (input) {
                    input.value += emoji;
                    input.focus();
                }
                picker.classList.add('hidden');
            };
            picker.appendChild(button);
        });
        
        document.body.appendChild(picker);
        
        // Close picker when clicking outside
        document.addEventListener('click', (e) => {
            if (!picker.contains(e.target) && !e.target.closest('[onclick="toggleEmojiPicker()"]')) {
                picker.classList.add('hidden');
            }
        });
        
        return picker;
    }
    
    // Voice recording
    function initVoiceRecording() {
        const voiceButton = document.getElementById('voice-record-button');
        if (!voiceButton) return;
        
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        
        voiceButton.addEventListener('mousedown', startRecording);
        voiceButton.addEventListener('touchstart', startRecording);
        
        document.addEventListener('mouseup', stopRecording);
        document.addEventListener('touchend', stopRecording);
        
        async function startRecording(e) {
            e.preventDefault();
            
            if (isRecording) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await sendVoiceMessage(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                isRecording = true;
                voiceButton.classList.add('recording');
                
                // Visual feedback
                showRecordingIndicator();
            } catch (error) {
                console.error('Recording failed:', error);
                showNotification('Microphone access denied', 'error');
            }
        }
        
        function stopRecording() {
            if (isRecording && mediaRecorder) {
                mediaRecorder.stop();
                isRecording = false;
                voiceButton.classList.remove('recording');
                hideRecordingIndicator();
            }
        }
        
        function showRecordingIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'recording-indicator';
            indicator.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded-full flex items-center space-x-2';
            indicator.innerHTML = `
                <div class="w-3 h-3 bg-white rounded-full animate-pulse"></div>
                <span>Recording...</span>
            `;
            document.body.appendChild(indicator);
        }
        
        function hideRecordingIndicator() {
            const indicator = document.getElementById('recording-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        async function sendVoiceMessage(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'voice-message.webm');
            formData.append('room_id', window.chat.config.roomId);
            
            try {
                const response = await fetch('/chat/send-voice/', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': getCSRFToken()
                    }
                });
                
                if (response.ok) {
                    showNotification('Voice message sent', 'success');
                }
            } catch (error) {
                console.error('Failed to send voice message:', error);
                showNotification('Failed to send voice message', 'error');
            }
        }
    }
    
    // Utility functions
    async function toggleReaction(messageId, reaction) {
        try {
            const response = await fetch(`/chat/message/${messageId}/react/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify({ reaction })
            });
            
            if (response.ok) {
                const data = await response.json();
                updateReactionUI(messageId, data.reaction, data.reaction_count);
            }
        } catch (error) {
            console.error('Failed to toggle reaction:', error);
        }
    }
    
    async function pinMessage(messageId) {
        try {
            const response = await fetch(`/chat/message/${messageId}/pin/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCSRFToken()
                }
            });
            
            if (response.ok) {
                showNotification('Message pinned', 'success');
                updatePinnedMessages();
            }
        } catch (error) {
            console.error('Failed to pin message:', error);
        }
    }
    
    async function deleteMessage(messageId) {
        if (!confirm('Are you sure you want to delete this message?')) return;
        
        try {
            const response = await fetch(`/chat/message/${messageId}/delete/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCSRFToken()
                }
            });
            
            if (response.ok) {
                // Remove message from UI
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    messageElement.classList.add('opacity-50');
                    setTimeout(() => messageElement.remove(), 300);
                }
                showNotification('Message deleted', 'success');
            }
        } catch (error) {
            console.error('Failed to delete message:', error);
        }
    }
    
    function replyToMessage(messageId) {
        const messageElement = document.querySelector(`[data-message-id="${messageId}"] .message-bubble`);
        if (messageElement) {
            const content = messageElement.querySelector('.message-content')?.textContent || '';
            const sender = messageElement.closest('.message-item').querySelector('.message-sender')?.textContent || '';
            
            // Show reply preview
            const preview = document.getElementById('reply-preview') || createReplyPreview();
            preview.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <i class="fas fa-reply text-primary-500"></i>
                        <div>
                            <p class="text-sm font-medium">Replying to ${sender}</p>
                            <p class="text-xs text-gray-500 truncate">${content.substring(0, 50)}...</p>
                        </div>
                    </div>
                    <button onclick="cancelReply()" class="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            preview.classList.remove('hidden');
            
            // Store reply data
            window.currentReply = { messageId, sender, content };
        }
    }
    
    function createReplyPreview() {
        const preview = document.createElement('div');
        preview.id = 'reply-preview';
        preview.className = 'bg-gray-50 dark:bg-gray-800 border-l-4 border-primary-500 p-3 mb-4 rounded-r-lg';
        
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
            messageInput.parentElement.insertBefore(preview, messageInput);
        }
        
        return preview;
    }
    
    function cancelReply() {
        const preview = document.getElementById('reply-preview');
        if (preview) {
            preview.classList.add('hidden');
        }
        window.currentReply = null;
    }
    
    function forwardMessage(messageId) {
        // Open forward modal
        showForwardModal(messageId);
    }
    
    function showForwardModal(messageId) {
        const modalHTML = `
            <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                <div class="bg-white dark:bg-gray-800 rounded-2xl w-full max-w-md">
                    <div class="p-6 border-b border-gray-200 dark:border-gray-700">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Forward Message</h3>
                            <button onclick="closeModal()" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="mt-4">
                            <input type="text" 
                                   placeholder="Search chats..."
                                   class="w-full px-4 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg border-none focus:ring-2 focus:ring-primary-500">
                        </div>
                    </div>
                    <div class="p-4 max-h-96 overflow-y-auto">
                        <!-- Chat list for forwarding -->
                        <div class="space-y-2">
                            <!-- Chats will be loaded here -->
                        </div>
                    </div>
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700">
                        <button onclick="performForward('${messageId}')" 
                                class="w-full py-3 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium">
                            Forward
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    }
    
    async function performForward(messageId, chatIds) {
        try {
            const response = await fetch(`/chat/message/${messageId}/forward/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify({ chat_ids: chatIds })
            });
            
            if (response.ok) {
                showNotification('Message forwarded', 'success');
                closeModal();
            }
        } catch (error) {
            console.error('Failed to forward message:', error);
            showNotification('Failed to forward message', 'error');
        }
    }
    
    function copyMessage(messageId) {
        const messageElement = document.querySelector(`[data-message-id="${messageId}"] .message-content`);
        if (messageElement) {
            navigator.clipboard.writeText(messageElement.textContent)
                .then(() => showNotification('Message copied', 'success'))
                .catch(() => showNotification('Failed to copy', 'error'));
        }
    }
    
    function saveMessage(messageId) {
        // Add to saved messages
        const saved = JSON.parse(localStorage.getItem('saved_messages') || '[]');
        if (!saved.includes(messageId)) {
            saved.push(messageId);
            localStorage.setItem('saved_messages', JSON.stringify(saved));
            showNotification('Message saved', 'success');
        } else {
            showNotification('Message already saved', 'info');
        }
    }
    
    function openImageViewer(imageUrl) {
        const viewerHTML = `
            <div class="fixed inset-0 bg-black/90 flex items-center justify-center z-50">
                <div class="relative max-w-4xl max-h-[90vh]">
                    <img src="${imageUrl}" alt="Image" class="max-w-full max-h-full">
                    <div class="absolute top-4 right-4 flex space-x-2">
                        <a href="${imageUrl}" 
                           download
                           class="p-2 bg-white/20 hover:bg-white/40 rounded-full backdrop-blur-sm">
                            <i class="fas fa-download text-white"></i>
                        </a>
                        <button onclick="closeImageViewer()" 
                                class="p-2 bg-white/20 hover:bg-white/40 rounded-full backdrop-blur-sm">
                            <i class="fas fa-times text-white"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', viewerHTML);
    }
    
    function closeImageViewer() {
        const viewer = document.querySelector('.fixed.inset-0.bg-black\\/90');
        if (viewer) {
            viewer.remove();
        }
    }
    
    function getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
    }
</script>